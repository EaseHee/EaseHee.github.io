<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Dark Poole</title>
 <link href="/atom.xml" rel="self"/>
 <link href="http://localhost:4000/"/>
 <updated>2024-10-04T00:40:38+09:00</updated>
 <id>http://localhost:4000</id>
 <author>
   <name>Mark Otto</name>
   <email>markdotto@gmail.com</email>
 </author>

 
 <entry>
   <title>Java_02_</title>
   <link href="http://localhost:4000/2024/10/04/Java_01/"/>
   <updated>2024-10-04T00:00:00+09:00</updated>
   <id>http://localhost:4000/2024/10/04/Java_01</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;/2024/10/03/Java_02/&quot;&gt;이전 글&lt;/a&gt; &lt;a href=&quot;&quot;&gt;다음 글&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

</content>
 </entry>
 
 <entry>
   <title>Java_01_자바와 객체 지향</title>
   <link href="http://localhost:4000/2024/10/03/Java_02/"/>
   <updated>2024-10-03T00:00:00+09:00</updated>
   <id>http://localhost:4000/2024/10/03/Java_02</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;/2024/10/03/Java_00/&quot;&gt;이전 글&lt;/a&gt; &lt;a href=&quot;/2024/10/04/Java_01/&quot;&gt;다음 글&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;dt&gt;절차 지향 vs 객체 지향&lt;dd&gt;
프로그래밍은 과정과 절차, 기능을 중심으로 동작하는 방식과 &lt;br /&gt;
기능 수행 단위인 객체를 중심으로 동작하는 방식으로 구분한다고 한다.&lt;br /&gt;
대표적으로 C언어는 절차 지향 언어. C++, Python, Java는 객체 지향 언어로 구분한다. &lt;br /&gt;
그 차이를 이야기하는 것은 이제 처음 개발이라는 분야에 들어온 사람이 감당하기 어려운 부분이라고 생각하여... &lt;br /&gt;
앞으로 다룰 자바의 특징인 객체 지향에 대해서 보고 들은 내용을 돌이켜 보려고 한다.
&lt;/dd&gt;&lt;/dt&gt;

&lt;hr /&gt;

&lt;dt&gt;객체 지향 언어&lt;dd&gt;
이름에서도 알 수 있듯이 무언가를 구분하는 단위로써 객체라는 이름을 사용하고 있다. &lt;br /&gt;
즉, 객체는 `특정 기능을 수행하는 하나의 단위` 정도로 생각하면 될 것 같다. &lt;br /&gt;
객체 지향 프로그램이란 이런 기능 수행 단위로서의 객체를 이용하여 컴퓨터와 소통?하는 것을 의미하는 것이 아닐까 &lt;br /&gt;
이런 객체 지향 프로그래밍은 4자기 특징이 있다고 한다.
&lt;/dd&gt;&lt;/dt&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;객체 지향 프로그래밍의 네 가지 특징&lt;/p&gt;
&lt;h3 id=&quot;oop--object-oriented-prodramming&quot;&gt;OOP : Object-Oriented Prodramming&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 추상화&lt;/strong&gt;
&lt;br /&gt;
객체를 구분하는 과정에서 해당 객체가 가진 여러 특징 중 공통적이고 추상적인 속성, 기능을 추출하는 것.&lt;br /&gt;
추상적인 기능을 추출하는 과정에서 특정 객체에서 필요로 하는 단위로 구분하는 것이&lt;br /&gt; 
아래에서 다룰 객체 지향 설계를 위한 다섯 가지 원칙의 
네 번째 &lt;strong&gt;인터페이스 분리의 원칙&lt;/strong&gt;과도 관련이 있다고 생각한다. &lt;br /&gt;
추상화된 객체를 구체화하기 위해서는 상속이라는 개념으로 해결할 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 캡슐화&lt;/strong&gt;
&lt;br /&gt;
캡슐화라는 말은 직역하면 기능과 속성의 단위로서 객체(클래스)를 외부와 구분하는 것으로 볼 수 있다. &lt;br /&gt;
객체로 클래스를 구분하고 이 클래스에 접근하기 위해서는 접근할 수 있는 유효 범위를 만족해야 한다.&lt;br /&gt;
접근 제한자 혹은 접근 지정자라고 부르는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;public&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;protected&lt;/code&gt;, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;private&lt;/code&gt;가 그 열쇠이다.&lt;br /&gt;
속성과 기능으로 객체를 구분했다고 하더라도 유사한 속성, 기능의 경우 따로 구분하거나 묶어줄 필요가 있는데 &lt;br /&gt;
이 때, 패키지라는 개념으로 객체를 묶어줄 수 있다. &lt;br /&gt;
이렇게 패키지로 객체를 구분한 경우 접근의 제한에서 비교적 자유로워질 수 있는데 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;default&lt;/code&gt;와 관련이 있다. &lt;br /&gt;
접근을 제한하는 범위가 가장 좁은 건 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;private&lt;/code&gt;으로 의미 그대로 사적인, 보호되는 뜻이다. &lt;br /&gt;
캡슐화된 객체는 외부로부터의 접근을 제한하며 객체의 속성, 기능의 노출을 막을 수 있다. &lt;br /&gt;
이렇게 &lt;strong&gt;객체의 정보를 보호하고 숨기는 것&lt;/strong&gt;이 캡슐화의 핵심이라고 한다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 상속성&lt;/strong&gt;
&lt;br /&gt;
객체를 추상화하여 특정 기능으로 구분하고 분리했다면 &lt;strong&gt;해당 기능을 구체화할 수 있도록&lt;/strong&gt; 길을 열어두어야 한다. &lt;br /&gt;
그 길이 바로 상속과 구현이다. &lt;br /&gt;
추상화된 객체를 구체화하기 위해서 상속하며 자식은 해당 기능의 기본 뼈대를 상속받게 된다. &lt;br /&gt;
뼈대에 살을 붙이는 과정이 오버라이딩이다. &lt;br /&gt; 
익숙하지 않은 용어에 오버로딩과 헷갈리는 경우가 있는데 이는 다형성에서 다루려고 한다.&lt;br /&gt;
상속 관계에서는 참조 여부가 중요한 개념이 되는데 부모는 자식을 참조(참조 주소값을 저장)할 수 있지만 자식은 부모를 참조할 수 없다.&lt;br /&gt; 
부모는 자식의 참조값을 저장할 수 있다는 것 때문에 매개변수의 타입을 정하는 시점에서 &lt;br /&gt;
여러 자식의 타입이 서로 다른 경우 구체적인 하나의 자식 타입이 아닌 부모의 타입으로 설정할 수 있다.&lt;br /&gt;
이로써 인자로 모든 자식을 전달받더라도 정상적으로 작동할 수 있다.
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 다형성&lt;/strong&gt;
&lt;br /&gt;
하나의 객체가 다양한 기능을 수행할 수 있도록 하는 개념으로 상속과 유사하지만.&lt;br /&gt;
상속은 객체의 데이터 타입이 결정되는 수직적인 방향의 기능 확장이라면&lt;br /&gt;
다형성은 객체가 수행할 수 있는 기능(역할)이 넓어지는 수평적인 방향의 기능 확장처럼 보인다.&lt;br /&gt;
위의 상속성에서 언급한 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;메서드 오버로딩&lt;/code&gt;이 다형성의 대표적인 예이다.&lt;br /&gt;
오버로딩은 과적(많이 쌓았다는 뜻)으로 같은 메서드를 매개 변수의 타입과 개수를 다르게 설정하여 &lt;br /&gt;
동일한 기능을 수행하는 메서드를 하나의 이름으로 여러 상황에 맞게 사용할 수 있도록 길을 열어둔 것이다. &lt;br /&gt;
이는 바로 다음에 다룰 네 번째 특징인 다형성과 그 다음에 다룰 객체 지향 설계를 위한 다섯 가지 원칙의 
두 번째 &lt;strong&gt;개방 폐쇄의 원칙&lt;/strong&gt;과도 관련이 있다고 생각한다. &lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이미 언급했듯 이런 객체 지향 프로그램을 설계하기 위한 중요한 다섯 가지 원칙이 있다고 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;객체-지향-설계의-다섯-가지-원칙-solid&quot;&gt;객체 지향 설계의 다섯 가지 원칙 (SOLID)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1. 단일 책임 원칙&lt;/strong&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;SRP : Single Responsibility Principle&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하나의 클래스나 메서드는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;하나의 기능만을 수행&lt;/code&gt;해야 한다는 것이다. &lt;br /&gt;
즉, 다른 기능을 수행해야 하는 경우, 별도의 클래스나 메서드로 분리해야 한다는 것이 첫 번째 원칙이다. &lt;br /&gt;
기능에 맞는 단위로서의 캡슐화가 그 핵심이 아닐까 생각해본다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 개방 폐쇄 원칙&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;OCP : Open-Closed Principle&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;자바에서는 특정 클래스나 인터페이스를 상속하거나 구현할 수 있다. &lt;br /&gt;
이처럼 부모의 기능을 확장하는 데에는 열려 있고, &lt;br /&gt;
기능을 수정하거나 추가할 때에는 자식의 로직 전부를 수정하지 않고 &lt;br /&gt;
부모(클래스 혹은 인터페이스)의 로직만을 수정하도록 &lt;br /&gt;
기능 수정, 추가에는 닫혀있는 설계를 지향하는 것이 두 번째 원칙이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 리스코프 치환 원칙&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;LSP : Liskov Subtituition Principle&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;(Subtitution) 치환 혹은 대체라는 건 바꾼다는 의미인데 &lt;br /&gt;
상속 관계에서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;자식은 부모의 기능을 모두 수행할 수 있어야 한다&lt;/code&gt;는 뜻이다. &lt;br /&gt;
이 원칙은 다형성과도 연관이 있는 것 같다. &lt;br /&gt;
이렇게 자식을 부모로 대체하는 경우에도 기능에서 문제가 없도록 하는 것이 세 번째 원칙이다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 인터페이스 분리 원칙&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ISP : Interface Segregation Principle&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;인터페이스란 실체를 가질 수 없는 클래스로 구현을 목적으로 존재한다. &lt;br /&gt;
자바에서는 클래스의 다중 상속을 지원하지 않기 때문에 여러 기능을 동시에 수행하기 위해서는 인터페이스를 구현하는 방식으로 해결해야 한다. &lt;br /&gt;
즉, 인터페이스는 다중 구현이 가능하다는 의미로 추상 클래스와의 가장 큰 차이라고 할 수 있다. &lt;br /&gt;
&lt;strong&gt;추상클래스는 추상메서드를 하나 이상 가지고 있는 클래스&lt;/strong&gt;로 추상메서드는 자식이 반드시 구현해야 하는 메서드가 된다. &lt;br /&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;cf. final 메서드는 자식이 오버라이딩할 수 없다. final 클래스는 상속할 수 없다.&lt;br /&gt; 
반드시 구현해야 하는 기능이 있는 경우 인터페이스가 아닌 추상클래스로 생성한다.  &lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ex. InputStream : read()와 같은 구체적인 기능을 정의&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;다중 상속을 위해 인터페이스는 기능으로 구분되고, 기능에 특화되다보니 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-able&lt;/code&gt; 이라는 접미사를 이름에 붙이는 경우가 많다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ex. Iterable, Comparable, ...&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;하지만 인터페이스는 구현하게 되면 해당 인터페이스가 가지고 있는 모든 메서드를 재정의해야 한다. &lt;br /&gt; 
필요 없는 기능의 메서드까지 재정의해야 하는 문제를 막기 위해 &lt;br /&gt;
인터페이스를 해당 기능을 기준으로 분리한 후 필요한 기능의 인터페이스만을 구현하도록 하는 것이 네 번째 원칙이다. &lt;br /&gt;
이건 첫 번째 원칙인 단일 책임 원칙과도 관련이 있는 것 같다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5. 의존성 역전 원칙&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;DIP : Dependency Inversion PrinCiple&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;객체는 기능에 따라 분리되어 있으며, 필요 시 해당 객체의 인스턴스를 생성한 후 기능을 수행할 수 있다.&lt;br /&gt;
이렇게 다른 객체를 상속하거나 구현하는 경우 의존관계가 생기게 된다. &lt;br /&gt;
이 경우 부모가 구체적인 기능을 수행하고 있고 자식이 이를 상속하게 된다면 &lt;br /&gt;
자식은 해당 기능을 오버라이딩하지 않고 상속받아 사용할 수 있다.&lt;br /&gt;
하지만 자식이 다른 기능으로 변경하기 위해서는 다른 부모를 상속해야 하고&lt;br /&gt;
현재 부모를 상속함으로 수핼할 수 있던 구체적인 기능 의존 관계에 의해 문제가 생기게 된다.&lt;br /&gt;
만약 여러 객체에서 필요로 하는 기능이 있다면 해당 기능의 공통점을 추상화하여 인터페이스로 분리하는 것이  &lt;br /&gt;
해당 인터페이스만 구현하는 것으로 동일한 기능을 구현하면서도 다른 부모를 상속하더라도 기능을 정상적으로 수행할 수 있게 된다.&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>Java_00_들어가기 전에</title>
   <link href="http://localhost:4000/2024/10/03/Java_00/"/>
   <updated>2024-10-03T00:00:00+09:00</updated>
   <id>http://localhost:4000/2024/10/03/Java_00</id>
   <content type="html">&lt;p&gt;&lt;a href=&quot;/2024/10/03/Introduction_EN/&quot;&gt;이전 글&lt;/a&gt; &lt;a href=&quot;/2024/10/03/Java_02/&quot;&gt;다음 글&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로그래밍을-배우며&quot;&gt;프로그래밍을 배우며&lt;/h3&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;나에게&quot;&gt;나에게&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;백문 불여 일타 | 프로그래밍은 손으로 배운다 &lt;br /&gt;
보거나 들은 내용이 아무리 많아도 한번 직접 구현해본 것만 못하다. &lt;br /&gt;
&lt;strong&gt;&lt;em&gt;궁금한 부분이 생기면 찾아보기 전에 직접 코드를 작성해보고,&lt;/em&gt;&lt;/strong&gt; &lt;br /&gt;
&lt;strong&gt;&lt;em&gt;떠오르는 생각이 있다면 생각에 그치지 말고 직접 코드를 작성해 보자.&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;GIGO : Garbage In Garbage Out &lt;br /&gt;
쓰레기를 넣으면 쓰레기가 나온다. &lt;br /&gt;
&lt;strong&gt;&lt;em&gt;컴뮤터는 잘못이 없다. 문제가 생기면 나의 코드를 돌아보자.&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;
</content>
 </entry>
 
 <entry>
   <title>Introduction</title>
   <link href="http://localhost:4000/2024/10/03/Introduction_EN/"/>
   <updated>2024-10-03T00:00:00+09:00</updated>
   <id>http://localhost:4000/2024/10/03/Introduction_EN</id>
   <content type="html">&lt;h2 id=&quot;thisisheeegithubio-_-한글로-보기&quot;&gt;ThIsIsHeEe.github.io _ &lt;a href=&quot;/2024/10/03/Introduction&quot;&gt;한글로 보기&lt;/a&gt;&lt;/h2&gt;
&lt;h4 id=&quot;theme--darkpoole&quot;&gt;(Theme : &lt;a href=&quot;/DarkPoole.md&quot;&gt;DarkPoole&lt;/a&gt;)&lt;/h4&gt;

&lt;h3 id=&quot;welcome-to-my-personal-space-for-consideration&quot;&gt;Welcome to my personal space for consideration.&lt;/h3&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;TODO&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Study programming&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;HTML5&lt;/li&gt;
    &lt;li&gt;CSS3&lt;/li&gt;
    &lt;li&gt;JavaScript (ECMA6)&lt;/li&gt;
    &lt;li&gt;MariaDB (MYSQL)&lt;/li&gt;
    &lt;li&gt;Java
&lt;br /&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://github.com/ThIsIsHeEe/TeamProject.git&quot;&gt;Team Project&lt;/a&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;Project subject : ERP(Enterprise Resource Planning) for micro enterprise
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2024/10/03/Java_00&quot;&gt;Intro&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;To myself face up to challenge&lt;/strong&gt;
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;If I do just what I can, I won’t be better than I was.&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;I’m here to change myself, I won’t escape anything.&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;I trust me.&lt;br /&gt; If I believe, I can.&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 
 <entry>
   <title>소개 글</title>
   <link href="http://localhost:4000/2024/10/03/Introduction/"/>
   <updated>2024-10-03T00:00:00+09:00</updated>
   <id>http://localhost:4000/2024/10/03/Introduction</id>
   <content type="html">&lt;h2 id=&quot;thisisheeegithubio-_-in-english&quot;&gt;ThIsIsHeEe.github.io _ &lt;a href=&quot;/2024/10/03/Introduction_EN&quot;&gt;in English&lt;/a&gt;&lt;/h2&gt;
&lt;h4 id=&quot;테마--darkpoole&quot;&gt;(테마 : &lt;a href=&quot;/DarkPoole.md&quot;&gt;DarkPoole&lt;/a&gt;)&lt;/h4&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;이건희의-깃허브-페이지를-찾아주셔서-감사합니다&quot;&gt;이건희의 깃허브 페이지를 찾아주셔서 감사합니다.&lt;/h3&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;생각-정리를-위한-공간&quot;&gt;생각 정리를 위한 공간&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;프로그래밍 공부&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;HTML5&lt;/li&gt;
    &lt;li&gt;CSS3&lt;/li&gt;
    &lt;li&gt;JavaScript (ECMA6)&lt;/li&gt;
    &lt;li&gt;MariaDB (MYSQL)&lt;/li&gt;
    &lt;li&gt;Java
&lt;br /&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;a href=&quot;https://github.com/ThIsIsHeEe/TeamProject.git&quot;&gt;팀 프로젝트&lt;/a&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;프로젝트 주제 : 소상공인을 위한 ERP 시스템
&lt;br /&gt;&lt;br /&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2024/10/03/Java_00&quot;&gt;자바에 들어가기 앞서&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;도전에 앞서 할 수 있냐고 묻는 나에게&lt;/strong&gt;
&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;할 수 있는 것, 하고 싶은 것만 한다면, 내일도 어제와 다를 수 없다.&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;em&gt;나는 바뀌기 위해 이 자리에 섰고, 절대 도망가지 않는다.&lt;/em&gt;&lt;/strong&gt;&lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;나는 나를 믿는다.&lt;br /&gt; 할 수 있다고 믿으면 할 수 있다.&lt;/strong&gt;&lt;/p&gt;
</content>
 </entry>
 

</feed>
