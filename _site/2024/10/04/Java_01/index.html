<!DOCTYPE html>
<html lang="en" data-theme="dark-poole">
  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      Java_01_자바와 객체 지향
    
  </title>

  <link rel="stylesheet" href="/styles.css">
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="/assets/favicon.ico">
  <link rel="alternate" type="application/atom+xml" title="Dark Poole" href="/atom.xml">

  <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Java_01_자바와 객체 지향" />
<meta name="author" content="Mark Otto" />
<meta property="og:locale" content="en_US" />
<link rel="canonical" href="http://localhost:4000/2024/10/04/Java_01/" />
<meta property="og:url" content="http://localhost:4000/2024/10/04/Java_01/" />
<meta property="og:site_name" content="Dark Poole" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-10-04T00:00:00+09:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Java_01_자바와 객체 지향" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Mark Otto","url":"https://twitter.com/mdo"},"dateModified":"2024-10-04T00:00:00+09:00","datePublished":"2024-10-04T00:00:00+09:00","headline":"Java_01_자바와 객체 지향","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2024/10/04/Java_01/"},"url":"http://localhost:4000/2024/10/04/Java_01/"}</script>
<!-- End Jekyll SEO tag -->

</head>


  <body>
    <div class="container content">
      <header class="masthead">
        <h3 class="masthead-title">
          <a href="/index" title="Home">EaseHee</a>

          <nav class="nav">
            
            <small><a href="/archive">Blog</a></small>
            
            <small><a href="/about">About</a></small>
            
          </nav>
        </h3>
      </header>

      <main>
        <article class="post">
  <h1 class="post-title">Java_01_자바와 객체 지향</h1>
  <time datetime="2024-10-04T00:00:00+09:00" class="post-date">04 Oct 2024</time>
  
  <div class="navigation">
    
      <a href="/2024/10/03/Java_00/">이전 글</a> : Java_00_들어가기 전에
    
    <br>
    
      <a href="/2024/10/05/Java_02/">다음 글</a> : Java_02_자바 가상 머신
    
  </div>

  <p><br /></p>

<hr />

<p><br /></p>

<dt>절차 지향 vs 객체 지향<dd>
프로그래밍은 과정과 절차, 기능을 중심으로 동작하는 방식과 <br />
기능 수행 단위인 객체를 중심으로 동작하는 방식으로 구분한다고 한다.<br />
대표적으로 C언어는 절차 지향 언어. C++, Python, Java는 객체 지향 언어로 구분한다. <br />
그 차이를 이야기하는 것은 이제 처음 개발이라는 분야에 들어온 사람이 감당하기 어려운 부분이라고 생각하여... <br />
앞으로 다룰 자바의 특징인 객체 지향에 대해서 보고 들은 내용을 돌이켜 보려고 한다.
</dd></dt>

<hr />

<dt>객체 지향 언어<dd>
이름에서도 알 수 있듯이 무언가를 구분하는 단위로써 객체라는 이름을 사용하고 있다. <br />
즉, 객체는 `특정 기능을 수행하는 하나의 단위` 정도로 생각하면 될 것 같다. <br />
객체 지향 프로그램이란 이런 기능 수행 단위로서의 객체를 이용하여 컴퓨터와 소통?하는 것을 의미하는 것이 아닐까 <br />
이런 객체 지향 프로그래밍은 4자기 특징이 있다고 한다.
</dd></dt>

<p><br /><br /></p>

<hr />

<p><br /><br /></p>

<p>객체 지향 프로그래밍의 네 가지 특징</p>
<h3 id="oop--object-oriented-prodramming">OOP : Object-Oriented Prodramming</h3>
<p><strong>1. 추상화</strong>
<br />
객체를 구분하는 과정에서 해당 객체가 가진 여러 특징 중 공통적이고 추상적인 속성, 기능을 추출하는 것.<br />
추상적인 기능을 추출하는 과정에서 특정 객체에서 필요로 하는 단위로 구분하는 것이<br /> 
아래에서 다룰 객체 지향 설계를 위한 다섯 가지 원칙의 
네 번째 <strong>인터페이스 분리의 원칙</strong>과도 관련이 있다고 생각한다. <br />
추상화된 객체를 구체화하기 위해서는 상속이라는 개념으로 해결할 수 있다.<br />
<br /><br /></p>

<p><strong>2. 캡슐화</strong>
<br />
캡슐화라는 말은 직역하면 기능과 속성의 단위로서 객체(클래스)를 외부와 구분하는 것으로 볼 수 있다. <br />
객체로 클래스를 구분하고 이 클래스에 접근하기 위해서는 접근할 수 있는 유효 범위를 만족해야 한다.<br />
접근 제한자 혹은 접근 지정자라고 부르는 <code class="language-plaintext highlighter-rouge">public</code>, <code class="language-plaintext highlighter-rouge">default</code>, <code class="language-plaintext highlighter-rouge">protected</code>, <code class="language-plaintext highlighter-rouge">private</code>가 그 열쇠이다.<br />
속성과 기능으로 객체를 구분했다고 하더라도 유사한 속성, 기능의 경우 따로 구분하거나 묶어줄 필요가 있는데 <br />
이 때, 패키지라는 개념으로 객체를 묶어줄 수 있다. <br />
이렇게 패키지로 객체를 구분한 경우 접근의 제한에서 비교적 자유로워질 수 있는데 이는 <code class="language-plaintext highlighter-rouge">default</code>와 관련이 있다. <br />
접근을 제한하는 범위가 가장 좁은 건 <code class="language-plaintext highlighter-rouge">private</code>으로 의미 그대로 사적인, 보호되는 뜻이다. <br />
캡슐화된 객체는 외부로부터의 접근을 제한하며 객체의 속성, 기능의 노출을 막을 수 있다. <br />
이렇게 <strong>객체의 정보를 보호하고 숨기는 것</strong>이 캡슐화의 핵심이라고 한다.
<br /><br /></p>

<p><strong>3. 상속성</strong>
<br />
객체를 추상화하여 특정 기능으로 구분하고 분리했다면 <strong>해당 기능을 구체화할 수 있도록</strong> 길을 열어두어야 한다. <br />
그 길이 바로 상속과 구현이다. <br />
추상화된 객체를 구체화하기 위해서 상속하며 자식은 해당 기능의 기본 뼈대를 상속받게 된다. <br />
뼈대에 살을 붙이는 과정이 오버라이딩이다. <br /> 
익숙하지 않은 용어에 오버로딩과 헷갈리는 경우가 있는데 이는 다형성에서 다루려고 한다.<br />
상속 관계에서는 참조 여부가 중요한 개념이 되는데 부모는 자식을 참조(참조 주소값을 저장)할 수 있지만 자식은 부모를 참조할 수 없다.<br /> 
부모는 자식의 참조값을 저장할 수 있다는 것 때문에 매개변수의 타입을 정하는 시점에서 <br />
여러 자식의 타입이 서로 다른 경우 구체적인 하나의 자식 타입이 아닌 부모의 타입으로 설정할 수 있다.<br />
이로써 인자로 모든 자식을 전달받더라도 정상적으로 작동할 수 있다.
<br /><br /></p>

<p><strong>4. 다형성</strong>
<br />
하나의 객체가 다양한 기능을 수행할 수 있도록 하는 개념으로 상속과 유사하지만.<br />
상속은 객체의 데이터 타입이 결정되는 수직적인 방향의 기능 확장이라면<br />
다형성은 객체가 수행할 수 있는 기능(역할)이 넓어지는 수평적인 방향의 기능 확장처럼 보인다.<br />
위의 상속성에서 언급한 <code class="language-plaintext highlighter-rouge">메서드 오버로딩</code>이 다형성의 대표적인 예이다.<br />
오버로딩은 과적(많이 쌓았다는 뜻)으로 같은 메서드를 매개 변수의 타입과 개수를 다르게 설정하여 <br />
동일한 기능을 수행하는 메서드를 하나의 이름으로 여러 상황에 맞게 사용할 수 있도록 길을 열어둔 것이다. <br />
이는 바로 다음에 다룰 네 번째 특징인 다형성과 그 다음에 다룰 객체 지향 설계를 위한 다섯 가지 원칙의 
두 번째 <strong>개방 폐쇄의 원칙</strong>과도 관련이 있다고 생각한다. <br />
<br /><br /></p>

<p>이미 언급했듯 이런 객체 지향 프로그램을 설계하기 위한 중요한 다섯 가지 원칙이 있다고 한다.</p>

<p><br /><br /></p>

<hr />

<p><br /><br /></p>

<h3 id="객체-지향-설계의-다섯-가지-원칙-solid">객체 지향 설계의 다섯 가지 원칙 (SOLID)</h3>

<p><strong>1. 단일 책임 원칙</strong><br /></p>
<ul>
  <li><strong>SRP : Single Responsibility Principle</strong></li>
</ul>

<p>하나의 클래스나 메서드는 <code class="language-plaintext highlighter-rouge">하나의 기능만을 수행</code>해야 한다는 것이다. <br />
즉, 다른 기능을 수행해야 하는 경우, 별도의 클래스나 메서드로 분리해야 한다는 것이 첫 번째 원칙이다. <br />
기능에 맞는 단위로서의 캡슐화가 그 핵심이 아닐까 생각해본다.</p>

<p><br /></p>

<p><strong>2. 개방 폐쇄 원칙</strong></p>
<ul>
  <li><strong>OCP : Open-Closed Principle</strong></li>
</ul>

<p>자바에서는 특정 클래스나 인터페이스를 상속하거나 구현할 수 있다. <br />
이처럼 부모의 기능을 확장하는 데에는 열려 있고, <br />
기능을 수정하거나 추가할 때에는 자식의 로직 전부를 수정하지 않고 <br />
부모(클래스 혹은 인터페이스)의 로직만을 수정하도록 <br />
기능 수정, 추가에는 닫혀있는 설계를 지향하는 것이 두 번째 원칙이다.</p>

<p><br /></p>

<p><strong>3. 리스코프 치환 원칙</strong></p>
<ul>
  <li><strong>LSP : Liskov Subtituition Principle</strong></li>
</ul>

<p>(Subtitution) 치환 혹은 대체라는 건 바꾼다는 의미인데 <br />
상속 관계에서 <code class="language-plaintext highlighter-rouge">자식은 부모의 기능을 모두 수행할 수 있어야 한다</code>는 뜻이다. <br />
이 원칙은 다형성과도 연관이 있는 것 같다. <br />
이렇게 자식을 부모로 대체하는 경우에도 기능에서 문제가 없도록 하는 것이 세 번째 원칙이다.</p>

<p><br /></p>

<p><strong>4. 인터페이스 분리 원칙</strong></p>
<ul>
  <li><strong>ISP : Interface Segregation Principle</strong></li>
</ul>

<p>인터페이스란 실체를 가질 수 없는 클래스로 구현을 목적으로 존재한다. <br />
자바에서는 클래스의 다중 상속을 지원하지 않기 때문에 여러 기능을 동시에 수행하기 위해서는 인터페이스를 구현하는 방식으로 해결해야 한다. <br />
즉, 인터페이스는 다중 구현이 가능하다는 의미로 추상 클래스와의 가장 큰 차이라고 할 수 있다. <br />
<strong>추상클래스는 추상메서드를 하나 이상 가지고 있는 클래스</strong>로 추상메서드는 자식이 반드시 구현해야 하는 메서드가 된다. <br /></p>
<blockquote>
  <p>cf. final 메서드는 자식이 오버라이딩할 수 없다. final 클래스는 상속할 수 없다.<br /> 
반드시 구현해야 하는 기능이 있는 경우 인터페이스가 아닌 추상클래스로 생성한다.  <br />
<code class="language-plaintext highlighter-rouge">ex. InputStream : read()와 같은 구체적인 기능을 정의</code></p>
</blockquote>

<p>다중 상속을 위해 인터페이스는 기능으로 구분되고, 기능에 특화되다보니 <code class="language-plaintext highlighter-rouge">-able</code> 이라는 접미사를 이름에 붙이는 경우가 많다.</p>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">ex. Iterable, Comparable, ...</code></p>
</blockquote>

<p>하지만 인터페이스는 구현하게 되면 해당 인터페이스가 가지고 있는 모든 메서드를 재정의해야 한다. <br /> 
필요 없는 기능의 메서드까지 재정의해야 하는 문제를 막기 위해 <br />
인터페이스를 해당 기능을 기준으로 분리한 후 필요한 기능의 인터페이스만을 구현하도록 하는 것이 네 번째 원칙이다. <br />
이건 첫 번째 원칙인 단일 책임 원칙과도 관련이 있는 것 같다.</p>

<p><br /></p>

<p><strong>5. 의존성 역전 원칙</strong></p>
<ul>
  <li><strong>DIP : Dependency Inversion PrinCiple</strong></li>
</ul>

<p>객체는 기능에 따라 분리되어 있으며, 필요 시 해당 객체의 인스턴스를 생성한 후 기능을 수행할 수 있다.<br />
이렇게 다른 객체를 상속하거나 구현하는 경우 의존관계가 생기게 된다. <br />
이 경우 부모가 구체적인 기능을 수행하고 있고 자식이 이를 상속하게 된다면 <br />
자식은 해당 기능을 오버라이딩하지 않고 상속받아 사용할 수 있다.<br />
하지만 자식이 다른 기능으로 변경하기 위해서는 다른 부모를 상속해야 하고<br />
현재 부모를 상속함으로 수행할 수 있던 구체적인 기능이 의존 관계에 의해 문제가 생기게 된다.<br />
만약 여러 객체에서 필요로 하는 기능이 있다면 해당 기능의 공통점을 추상화하여 인터페이스로 분리하는 것이  <br />
해당 인터페이스만 구현하는 것으로 동일한 기능을 구현하면서도 다른 부모를 상속하더라도 기능을 정상적으로 수행할 수 있게 된다.</p>


</article>


<aside class="related">
  <h3>Related posts</h3>
  <ul class="related-posts">
    
      <li>
        <a href="/2024/10/07/Java_04/">
          Java_04_클래스와 인스턴스
          <small><time datetime="2024-10-07T00:00:00+09:00">07 Oct 2024</time></small>
        </a>
      </li>
    
      <li>
        <a href="/2024/10/06/Java_03/">
          Java_03_자바와 메모장
          <small><time datetime="2024-10-06T00:00:00+09:00">06 Oct 2024</time></small>
        </a>
      </li>
    
      <li>
        <a href="/2024/10/05/Java_02/">
          Java_02_자바 가상 머신
          <small><time datetime="2024-10-05T00:00:00+09:00">05 Oct 2024</time></small>
        </a>
      </li>
    
  </ul>
</aside>

      </main>

      <footer class="footer">
        <small>
          &copy;
          <time datetime="2024-10-07T22:23:23+09:00"
            >2024</time
          >. All rights reserved.
        </small>
      </footer>
    </div>

    
  </body>
</html>
