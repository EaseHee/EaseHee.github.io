---
layout: post
title: "SpringBoot_Board_게시판 만들기"
date: 2024-10-28
categories: blog
category: Web
---

<br>

---
# Board (게시판) with Spring Data Jpa<br>

"프로그래밍을 배웠다면 혼자 게시판 하나는 만들 수 있어야 한다." 

프로그래밍을 가르쳐주신 선생님께서 해주신 말씀이었다.

그래서 게시판을 만들 때 필요한 기본 요소를 순서에 따라 정리해보려고 한다. 

> 개발 환경 : Java(21) + SpringBoot(ver.3) + MariaDB

<pre>
1. 글과 관련된 정보를 저장할 데이터 베이스 (테이블: RDBMS)
2. 데이터의 추가, 조회, 수정, 삭제 (CRUD)
3. 게시글의 페이지 단위 구분 (Paging)
4. 답글 기능 (Reply)
</pre>

<hr>

# 1. 데이터 베이스 테이블 생성

MariaDB  SQL 문으로 작성.
<pre><code>
CREATE TABLE board (
    num         int             primary key,
    title       varchar(50)     not null,
    name        varchar(20)     not null,
    pass        varchar(20)     not null, 
    content     text,
    mail        varchar(30),
    bip         varchar(20),    -- ip
    bdate       varchar(20),    -- 등록일
    readcnt     int,            -- 조회수
    gnum        int,            -- 게시글 답글 시 그룹화 : group num
    onum        int,            -- 정렬 기준 번호 : order num
    nested      int             -- 들여쓰기
)CHARSET=UTF8;
</code></pre>

<br>
글 제목, 작성자, 비밀번호(인증), 글 내용, ... <br>
게시글의 답글 기능을 구현하기 위한 <strong>그룹, 정렬 번호와 들여쓰기 번호</strong>를 필드로 생성.

<pre class="bg- bk" style="width: fit-content;">
+---------+-------------+------+-----+---------+-------+
| Field   | Type        | Null | Key | Default | Extra |
+---------+-------------+------+-----+---------+-------+
| num     | int(11)     | NO   | PRI | NULL    |       |
| name    | varchar(20) | NO   |     | NULL    |       |
| pass    | varchar(20) | NO   |     | NULL    |       |
| mail    | varchar(30) | YES  |     | NULL    |       |
| title   | varchar(50) | YES  |     | NULL    |       |
| cont    | text        | YES  |     | NULL    |       |
| bip     | varchar(20) | YES  |     | NULL    |       |
| bdate   | varchar(20) | YES  |     | NULL    |       |
| readcnt | int(11)     | YES  |     | NULL    |       |
| gnum    | int(11)     | YES  |     | NULL    |       |
| onum    | int(11)     | YES  |     | NULL    |       |
| nested  | int(11)     | YES  |     | NULL    |       |
+---------+-------------+------+-----+---------+-------+
</pre>

<br>
<details>
<summary class="summary-title">@Entity <br>
&emsp;테이블과 매핑되는 자바 클래스를 정의</summary>

</details>


<br>
<hr>

# 2. CRUD
<br>
<h3>SpringBoot를 활용한 웹 페이지 개발 과정 상 클라이언트의 요청에 따른 단계 구분</h3>
<br>
<pre class="font-lg rec bg-bk">
1. (Read)   list.html, detail.html
2. (Create) insert.html → list.html / detail.html
3. (Update) update.html → list.html / detail.html
4. (Delete) ... → list.html
</pre>
<br>

<h3>☑️ JpaRepository → Method Naming Rule</h3>

<details>
<summary class="summary-title">@Repository<br>
&emsp;DB 연동 & CRUD</summary>


<details>
<summary>findAll()<br>
&emsp;전체 레코드 조회</summary>

</details>


<details>
<summary>findById(PK)<br>
&emsp;기본키(PK)에 해당하는 레코드 1개 조회</summary>

</details>


<details>
<summary>findByNameContaining(name)<br>
&emsp;검색 조건에 해당하는 레코드 조회</summary>

</details>


<details>
<summary>save(Entity)<br>
&emsp;데이터 추가, 수정</summary>

</details>


<details>
<summary>remove(PK)<br>
&emsp;데이터 삭제</summary>

</details>

</details>

<br>
<hr>

# 3. 게시글의 페이지 구분

Page, Pageable, PageRequest

Sort, Order


## package : org.springframework.data.domain

# ☑️ Page &  Pageable

<details>
<summary class="summary-title">Page<br>
&emsp;검색 결과의 페이징된 정보를 담는 컨테이너 인터페이스<br>
&emsp;데이터베이스에서 조회한 결과를 페이징 처리하여 각 페이지에 해당하는 요소들을 보관<br>
&emsp;특정 페이지의 데이터와 함께 페이징 관련 정보를 포함<br>
&emsp;(ex. 총 페이지 수, 현재 페이지, 전체 데이터 수)</summary>
<h3>주요 메서드</h3>
<div markdown="1">

```java
getPageable(): Pageable 인터페이스 구현체 반환
getContent(): 현재 페이지의 실제 데이터 목록을 반환
getTotalElements(): 전체 데이터 수를 반환
getTotalPages(): 총 페이지 수를 반환
getNumber(): 현재 페이지 번호를 반환(0부터 시작)
getSize(): 페이지당 항목 수를 반환
hasNext(), hasPrevious(): 다음 페이지 또는 이전 페이지가 있는지 확인
```
</div>

<details>
<summary class="summary-title">API 내용 확인</summary>
<div markdown="1">

```java
package org.springframework.data.domain;

import java.util.Collections;
import java.util.function.Function;

/**
    * A page is a sublist of a list of objects. It allows gain information about the position of it in the containing
    * entire list.
    *
    * @param <T>
    * @author Oliver Gierke
    */
public interface Page<T> extends Slice<T> {

    /**
        * Creates a new empty {@link Page}.
        *
        * @return
        * @since 2.0
        */
    static <T> Page<T> empty() {
        return empty(Pageable.unpaged());
    }

    /**
        * Creates a new empty {@link Page} for the given {@link Pageable}.
        *
        * @param pageable must not be {@literal null}.
        * @return
        * @since 2.0
        */
    static <T> Page<T> empty(Pageable pageable) {
        return new PageImpl<>(Collections.emptyList(), pageable, 0);
    }

    /**
        * Returns the number of total pages.
        *
        * @return the number of total pages
        */
    int getTotalPages();

    /**
        * Returns the total amount of elements.
        *
        * @return the total amount of elements
        */
    long getTotalElements();

    /**
        * Returns a new {@link Page} with the content of the current one mapped by the given {@link Function}.
        *
        * @param converter must not be {@literal null}.
        * @return a new {@link Page} with the content of the current one mapped by the given {@link Function}.
        * @since 1.10
        */
    @Override
    <U> Page<U> map(Function<? super T, ? extends U> converter);
}
```
</div>
</details>
</details>


<details>
<summary class="summary-title">Pageable<br>
&emsp;페이징을 위한 정보 : 요청 페이지 번호, 페이지 크기, 정렬 방식을 정의<br>
&emsp;페이지 번호와 크기를 설정하여 페이징 요청</summary>
<h3>주요 메서드</h3>
<div markdown="1">

```java
getPageNumber(): 요청한 페이지 번호를 반환
getPageSize(): 요청한 페이지의 크기(항목 수)를 반환
getSort(): 요청한 정렬 기준을 반환
next(), previousOrFirst(): 다음 페이지나 이전 페이지에 대한 Pageable 인스턴스 반환
```
</div>

<details>
<summary>API 내용 확인</summary>
<div markdown="1">

```java
package org.springframework.data.domain;

import java.util.Optional;

import org.springframework.util.Assert;

/**
    * Abstract interface for pagination information.
    *
    * @author Oliver Gierke
    * @author Mark Paluch
    * @author Christoph Strobl
    */
public interface Pageable {

    /**
        * Returns a {@link Pageable} instance representing no pagination setup.
        *
        * @return
        */
    static Pageable unpaged() {
        return unpaged(Sort.unsorted());
    }

    /**
        * Returns a {@link Pageable} instance representing no pagination setup having a defined result {@link Sort order}.
        *
        * @param sort must not be {@literal null}, use {@link Sort#unsorted()} if needed.
        * @return never {@literal null}.
        * @since 3.2
        */
    static Pageable unpaged(Sort sort) {
        return Unpaged.sorted(sort);
    }

    /**
        * Creates a new {@link Pageable} for the first page (page number {@code 0}) given {@code pageSize} .
        *
        * @param pageSize the size of the page to be returned, must be greater than 0.
        * @return a new {@link Pageable}.
        * @since 2.5
        */
    static Pageable ofSize(int pageSize) {
        return PageRequest.of(0, pageSize);
    }

    /**
        * Returns whether the current {@link Pageable} contains pagination information.
        *
        * @return
        */
    default boolean isPaged() {
        return true;
    }

    /**
        * Returns whether the current {@link Pageable} does not contain pagination information.
        *
        * @return
        */
    default boolean isUnpaged() {
        return !isPaged();
    }

    /**
        * Returns the page to be returned.
        *
        * @return the page to be returned or throws {@link UnsupportedOperationException} if the object is
        *         {@link #isUnpaged()}.
        * @throws UnsupportedOperationException if the object is {@link #isUnpaged()}.
        */
    int getPageNumber();

    /**
        * Returns the number of items to be returned.
        *
        * @return the number of items of that page or throws {@link UnsupportedOperationException} if the object is
        *         {@link #isUnpaged()}.
        * @throws UnsupportedOperationException if the object is {@link #isUnpaged()}.
        */
    int getPageSize();

    /**
        * Returns the offset to be taken according to the underlying page and page size.
        *
        * @return the offset to be taken or throws {@link UnsupportedOperationException} if the object is
        *         {@link #isUnpaged()}.
        * @throws UnsupportedOperationException if the object is {@link #isUnpaged()}.
        */
    long getOffset();

    /**
        * Returns the sorting parameters.
        *
        * @return
        */
    Sort getSort();

    /**
        * Returns the current {@link Sort} or the given one if the current one is unsorted.
        *
        * @param sort must not be {@literal null}.
        * @return
        */
    default Sort getSortOr(Sort sort) {

        Assert.notNull(sort, "Fallback Sort must not be null");

        return getSort().isSorted() ? getSort() : sort;
    }

    /**
        * Returns the {@link Pageable} requesting the next {@link Page}.
        *
        * @return
        */
    Pageable next();

    /**
        * Returns the previous {@link Pageable} or the first {@link Pageable} if the current one already is the first one.
        *
        * @return
        */
    Pageable previousOrFirst();

    /**
        * Returns the {@link Pageable} requesting the first page.
        *
        * @return
        */
    Pageable first();

    /**
        * Creates a new {@link Pageable} with {@code pageNumber} applied.
        *
        * @param pageNumber
        * @return a new {@link PageRequest} or throws {@link UnsupportedOperationException} if the object is
        *         {@link #isUnpaged()} and the {@code pageNumber} is not zero.
        * @since 2.5
        * @throws UnsupportedOperationException if the object is {@link #isUnpaged()}.
        */
    Pageable withPage(int pageNumber);

    /**
        * Returns whether there's a previous {@link Pageable} we can access from the current one. Will return
        * {@literal false} in case the current {@link Pageable} already refers to the first page.
        *
        * @return
        */
    boolean hasPrevious();

    /**
        * Returns an {@link Optional} so that it can easily be mapped on.
        *
        * @return
        */
    default Optional<Pageable> toOptional() {
        return isUnpaged() ? Optional.empty() : Optional.of(this);
    }

    /**
        * Returns an {@link Limit} from this pageable if the page request {@link #isPaged() is paged} or
        * {@link Limit#unlimited()} otherwise.
        *
        * @return
        * @since 3.2
        */
    default Limit toLimit() {

        if (isUnpaged()) {
            return Limit.unlimited();
        }

        return Limit.of(getPageSize());
    }

    /**
        * Returns an {@link OffsetScrollPosition} from this pageable if the page request {@link #isPaged() is paged}.
        * <p>
        * Given the exclusive nature of scrolling the {@link ScrollPosition} for {@code Page(0, 10)} translates an
        * {@link ScrollPosition#isInitial() initial} position, where as {@code Page(1, 10)} will point to the last element of
        * {@code Page(0,10)} resulting in {@link ScrollPosition#offset(long) ScrollPosition(9)}.
        *
        * @return new instance of {@link OffsetScrollPosition}.
        * @throws IllegalStateException if the request is {@link #isUnpaged()}
        * @since 3.1
        */
    default OffsetScrollPosition toScrollPosition() {

        if (isUnpaged()) {
            throw new IllegalStateException("Cannot create OffsetScrollPosition from an unpaged instance");
        }

        return getOffset() > 0 ? ScrollPosition.offset(getOffset() - 1 /* scrolling is exclusive */)
                : ScrollPosition.offset();
    }
}
```
</div> 
</details>
</details>


<details>
<summary class="summary-title">PageRequest<br>
&emsp;Pageable 인터페이스를 구현한 클래스<br>
&emsp;페이지 번호와 페이지 크기, 정렬 기준을 설정<br>
&emsp;Pageable 인터페이스를 구현한 클래스</summary>

<h3>주요 메서드 (with 생성자)</h3>
<h3>&emsp;static 메서드 of()</h3>
<div markdown="1">

```java
of() : 페이지 번호, 페이지 크기, 정렬 기준을 인자로 전달
"반환 타입 : PageRequest"
```
</div>

<details>
<summary>API 내용 확인</summary>
<div markdown="1">

```java
public class PageRequest extends AbstractPageRequest {

    private static final long serialVersionUID = -4541509938956089562L;

    private final Sort sort;

    /**
     * Creates a new {@link PageRequest} with sort parameters applied.
        *
        * @param pageNumber zero-based page number, must not be negative.
        * @param pageSize the size of the page to be returned, must be greater than 0.
        * @param sort must not be {@literal null}, use {@link Sort#unsorted()} instead.
        */
    protected PageRequest(int pageNumber, int pageSize, Sort sort) {

        super(pageNumber, pageSize);

        Assert.notNull(sort, "Sort must not be null");

        this.sort = sort;
    }

    /**
     * Creates a new unsorted {@link PageRequest}.
        *
        * @param pageNumber zero-based page number, must not be negative.
        * @param pageSize the size of the page to be returned, must be greater than 0.
        * @since 2.0
        */
    public static PageRequest of(int pageNumber, int pageSize) {
        return of(pageNumber, pageSize, Sort.unsorted());
    }

    /**
     * Creates a new {@link PageRequest} with sort parameters applied.
        *
        * @param pageNumber zero-based page number, must not be negative.
        * @param pageSize the size of the page to be returned, must be greater than 0.
        * @param sort must not be {@literal null}, use {@link Sort#unsorted()} instead.
        * @since 2.0
        */
    public static PageRequest of(int pageNumber, int pageSize, Sort sort) {
        return new PageRequest(pageNumber, pageSize, sort);
    }

    /**
     * Creates a new {@link PageRequest} with sort direction and properties applied.
        *
        * @param pageNumber zero-based page number, must not be negative.
        * @param pageSize the size of the page to be returned, must be greater than 0.
        * @param direction must not be {@literal null}.
        * @param properties must not be {@literal null}.
        * @since 2.0
        */
    public static PageRequest of(int pageNumber, int pageSize, Direction direction, String... properties) {
        return of(pageNumber, pageSize, Sort.by(direction, properties));
    }

    /**
     * Creates a new {@link PageRequest} for the first page (page number {@code 0}) given {@code pageSize} .
        *
        * @param pageSize the size of the page to be returned, must be greater than 0.
        * @return a new {@link PageRequest}.
        * @since 2.5
        */
    public static PageRequest ofSize(int pageSize) {
        return PageRequest.of(0, pageSize);
    }

    @Override
    public Sort getSort() {
        return sort;
    }

    @Override
    public PageRequest next() {
        return new PageRequest(getPageNumber() + 1, getPageSize(), getSort());
    }

    @Override
    public PageRequest previous() {
        return getPageNumber() == 0 ? this : new PageRequest(getPageNumber() - 1, getPageSize(), getSort());
    }

    @Override
    public PageRequest first() {
        return new PageRequest(0, getPageSize(), getSort());
    }

    @Override
    public boolean equals(@Nullable Object obj) {

        if (this == obj) {
            return true;
        }

        if (!(obj instanceof PageRequest that)) {
            return false;
        }

        return super.equals(that) && sort.equals(that.sort);
    }

    /**
     * Creates a new {@link PageRequest} with {@code pageNumber} applied.
        *
        * @param pageNumber
        * @return a new {@link PageRequest}.
        * @since 2.5
        */
    @Override
    public PageRequest withPage(int pageNumber) {
        return new PageRequest(pageNumber, getPageSize(), getSort());
    }

    /**
     * Creates a new {@link PageRequest} with {@link Direction} and {@code properties} applied.
        *
        * @param direction must not be {@literal null}.
        * @param properties must not be {@literal null}.
        * @return a new {@link PageRequest}.
        * @since 2.5
        */
    public PageRequest withSort(Direction direction, String... properties) {
        return new PageRequest(getPageNumber(), getPageSize(), Sort.by(direction, properties));
    }

    /**
     * Creates a new {@link PageRequest} with {@link Sort} applied.
        *
        * @param sort must not be {@literal null}.
        * @return a new {@link PageRequest}.
        * @since 2.5
        */
    public PageRequest withSort(Sort sort) {
        return new PageRequest(getPageNumber(), getPageSize(), sort);
    }

    @Override
    public int hashCode() {
        return 31 * super.hashCode() + sort.hashCode();
    }

    @Override
    public String toString() {
        return String.format("Page request [number: %d, size %d, sort: %s]", getPageNumber(), getPageSize(), sort);
    }

}
```
</div>
</details>
</details>


# ☑️ Sort & Order


<details>
<summary class="summary-title">Sort<br>
&emsp;정렬 조건 설정 : 정의 및 추가</summary>
<h3>주요 메서드</h3>
<div markdown="1">

```java
by(Order): 정렬 기준 설정
and(): 정렬 기준 추가
```
</div>

<details> 
<summary>API 내용 확인</summary>
<div markdown="1">    

```java
package org.springframework.data.domain;

import java.io.Serial;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Optional;
import java.util.function.Function;
import java.util.stream.Collectors;

import org.springframework.data.util.MethodInvocationRecorder;
import org.springframework.data.util.MethodInvocationRecorder.Recorded;
import org.springframework.data.util.Streamable;
import org.springframework.lang.Nullable;
import org.springframework.util.Assert;
import org.springframework.util.ObjectUtils;
import org.springframework.util.StringUtils;

/**
    * Sort option for queries. You have to provide at least a list of properties to sort for that must not include
    * {@literal null} or empty strings. The direction defaults to {@link Sort#DEFAULT_DIRECTION}.
    *
    * @author Oliver Gierke
    * @author Thomas Darimont
    * @author Mark Paluch
    * @author Johannes Englmeier
    * @author Jan Kurella
    */
public class Sort implements Streamable<org.springframework.data.domain.Sort.Order>, Serializable {

    private static final @Serial long serialVersionUID = 5737186511678863905L;

    private static final Sort UNSORTED = Sort.by(new Order[0]);

    public static final Direction DEFAULT_DIRECTION = Direction.ASC;

    private final List<Order> orders;

    protected Sort(List<Order> orders) {
        this.orders = orders;
    }

    /**
        * Creates a new {@link Sort} instance.
        *
        * @param direction defaults to {@link Sort#DEFAULT_DIRECTION} (for {@literal null} cases, too)
        * @param properties must not be {@literal null} or contain {@literal null} or empty strings.
        */
    private Sort(Direction direction, @Nullable List<String> properties) {

        if (properties == null || properties.isEmpty()) {
            throw new IllegalArgumentException("You have to provide at least one property to sort by");
        }

        this.orders = properties.stream() //
                .map(it -> new Order(direction, it)) //
                .collect(Collectors.toList());
    }

    /**
        * Creates a new {@link Sort} for the given properties.
        *
        * @param properties must not be {@literal null}.
        * @return {@link Sort} for the given properties.
        */
    public static Sort by(String... properties) {

        Assert.notNull(properties, "Properties must not be null");

        return properties.length == 0 //
                ? Sort.unsorted() //
                : new Sort(DEFAULT_DIRECTION, Arrays.asList(properties));
    }

    /**
        * Creates a new {@link Sort} for the given {@link Order}s.
        *
        * @param orders must not be {@literal null}.
        * @return {@link Sort} for the given {@link Order}s.
        */
    public static Sort by(List<Order> orders) {

        Assert.notNull(orders, "Orders must not be null");

        return orders.isEmpty() ? Sort.unsorted() : new Sort(orders);
    }

    /**
        * Creates a new {@link Sort} for the given {@link Order}s.
        *
        * @param orders must not be {@literal null}.
        * @return {@link Sort} for the given {@link Order}s.
        */
    public static Sort by(Order... orders) {

        Assert.notNull(orders, "Orders must not be null");

        return new Sort(Arrays.asList(orders));
    }

    /**
        * Creates a new {@link Sort} for the given {@link Direction} and properties.
        *
        * @param direction must not be {@literal null}.
        * @param properties must not be {@literal null}.
        * @return {@link Sort} for the given {@link Direction} and properties.
        */
    public static Sort by(Direction direction, String... properties) {

        Assert.notNull(direction, "Direction must not be null");
        Assert.notNull(properties, "Properties must not be null");
        Assert.isTrue(properties.length > 0, "At least one property must be given");

        return Sort.by(Arrays.stream(properties)//
                .map(it -> new Order(direction, it))//
                .collect(Collectors.toList()));
    }

    /**
        * Creates a new {@link TypedSort} for the given type.
        *
        * @param type must not be {@literal null}.
        * @return {@link TypedSort} for the given type.
        * @since 2.2
        */
    public static <T> TypedSort<T> sort(Class<T> type) {
        return new TypedSort<>(type);
    }

    /**
        * Returns a {@link Sort} instances representing no sorting setup at all.
        *
        * @return unsorted Sort instance.
        */
    public static Sort unsorted() {
        return UNSORTED;
    }

    /**
        * Returns a new {@link Sort} with the current setup but descending order direction.
        *
        * @return a new {@link Sort} with the current setup but descending order direction.
        */
    public Sort descending() {
        return withDirection(Direction.DESC);
    }

    /**
        * Returns a new {@link Sort} with the current setup but ascending order direction.
        *
        * @return a new {@link Sort} with the current setup but ascending order direction.
        */
    public Sort ascending() {
        return withDirection(Direction.ASC);
    }

    /**
        * @return {@literal true} if this Sort instance is sorted, {@literal false} otherwise.
        */
    public boolean isSorted() {
        return !isEmpty();
    }

    @Override
    public boolean isEmpty() {
        return orders.isEmpty();
    }

    /**
        * @return {@literal true} if this Sort instance is unsorted, {@literal false} otherwise.
        */
    public boolean isUnsorted() {
        return !isSorted();
    }

    /**
        * Returns a new {@link Sort} consisting of the {@link Order}s of the current {@link Sort} combined with the given
        * ones.
        *
        * @param sort must not be {@literal null}.
        * @return a new {@link Sort} consisting of the {@link Order}s of the current {@link Sort} combined with the given
        *         ones.
        */
    public Sort and(Sort sort) {

        Assert.notNull(sort, "Sort must not be null");

        List<Order> these = new ArrayList<>(this.toList());

        for (Order order : sort) {
            these.add(order);
        }

        return Sort.by(these);
    }

    /**
        * Returns a new {@link Sort} with reversed sort {@link Order}s turning effectively asccending into descending sort
        * order and vice versa.
        *
        * @return a new {@link Sort} object with reversed sort orders applied.
        * @since 3.1
        */
    public Sort reverse() {

        List<Order> reversed = doReverse();

        return Sort.by(reversed);
    }

    protected List<Order> doReverse() {

        List<Order> reversed = new ArrayList<>(orders.size());

        for (Order order : this) {
            reversed.add(order.reverse());
        }

        return reversed;
    }

    /**
        * Returns the order registered for the given property.
        *
        * @param property name of the property that should be sorted.
        * @return the sort {@link Order} or {@literal null} if the property is not sorted by.
        */
    @Nullable
    public Order getOrderFor(String property) {

        for (Order order : this) {
            if (order.getProperty().equals(property)) {
                return order;
            }
        }

        return null;
    }

    @Override
    public Iterator<Order> iterator() {
        return this.orders.iterator();
    }

    @Override
    public boolean equals(@Nullable Object obj) {

        if (this == obj) {
            return true;
        }

        if (!(obj instanceof Sort that)) {
            return false;
        }

        return toList().equals(that.toList());
    }

    @Override
    public int hashCode() {

        int result = 17;
        result = 31 * result + orders.hashCode();
        return result;
    }

    @Override
    public String toString() {
        return isEmpty() ? "UNSORTED" : StringUtils.collectionToCommaDelimitedString(orders);
    }

    private Sort withDirection(Direction direction) {

        List<Order> result = new ArrayList<>(orders.size());

        for (Order order : this) {
            result.add(order.with(direction));
        }

        return Sort.by(result);
    }
```
</div>
</details>

<details>
<summary>Sort의 내부 클래스<br>
&emsp;1. enum Direction<br>
&emsp;2. enum NullHandling<br>
&emsp;3. static class Order<br>
&emsp;4. static class TypedSort extends Sort<br>
</summary>
<details>
<summary>public enum Direction</summary>
<div markdown="1">

```java
/**
    * Enumeration for sort directions.
    *
    * @author Oliver Gierke
    */
public enum Direction {
    ASC, DESC;
    /**
        * Returns whether the direction is ascending.
        *
        * @return {@literal true} if ascending, {@literal false} otherwise.
        * @since 1.13
        */
    public boolean isAscending() {
        return this.equals(ASC);
    }
    /**
        * Returns whether the direction is descending.
        *
        * @return {@literal true} if descending, {@literal false} otherwise.
        * @since 1.13
        */
    public boolean isDescending() {
        return this.equals(DESC);
    }
    /**
        * Returns the {@link Direction} enum for the given {@link String} value.
        *
        * @param value the direction name.
        * @return the {@link Direction} enum value for the given {@code value}.
        * @throws IllegalArgumentException in case the given value cannot be parsed into an enum value.
        */
    public static Direction fromString(String value) {
        try {
            return Direction.valueOf(value.toUpperCase(Locale.US));
        } catch (Exception e) {
            throw new IllegalArgumentException(String.format(
                    "Invalid value '%s' for orders given; Has to be either 'desc' or 'asc' (case insensitive)", value), e);
        }
    }
    /**
        * Returns the {@link Direction} enum for the given {@link String} or {@code Optional.empty()} if it cannot be
        * parsed into an enum value.
        *
        * @param value the direction name.
        * @return Optional holding the {@link Direction} enum value or empty, if {@code value} cannot be parsed into
        *         {@link Direction}.
        */
    public static Optional<Direction> fromOptionalString(String value) {
        if (ObjectUtils.isEmpty(value)) {
            return Optional.empty();
        }
        try {
            return Optional.of(fromString(value));
        } catch (IllegalArgumentException e) {
            return Optional.empty();
        }
    }
}
```
</div> 
</details>


<details>
<summary>public enum NullHandling</summary>
<div markdown="1">

```java
/**
    * Enumeration for null handling hints that can be used in {@link Order} expressions.
    *
    * @author Thomas Darimont
    * @since 1.8
    */
public enum NullHandling {
    /**
        * Lets the data store decide what to do with nulls.
        */
    NATIVE,
    /**
        * A hint to the used data store to order entries with null values before non null entries.
        */
    NULLS_FIRST,
    /**
        * A hint to the used data store to order entries with null values after non null entries.
        */
    NULLS_LAST;
}
```
</div> 
</details>

<details>
<summary>public static class Order</summary>
<div markdown="1">        

```java
/**
    * PropertyPath implements the pairing of an {@link Direction} and a property. It is used to provide input for
    * {@link Sort}
    *
    * @author Oliver Gierke
    * @author Kevin Raymond
    * @author Jens Schauder
    */
public static class Order implements Serializable {
    private static final @Serial long serialVersionUID = 1522511010900108987L;
    private static final boolean DEFAULT_IGNORE_CASE = false;
    private static final NullHandling DEFAULT_NULL_HANDLING = NullHandling.NATIVE;
    private final Direction direction;
    private final String property;
    private final boolean ignoreCase;
    private final NullHandling nullHandling;
    /**
        * Creates a new {@link Order} instance. if order is {@literal null} then order defaults to
        * {@link Sort#DEFAULT_DIRECTION}
        *
        * @param direction can be {@literal null}, will default to {@link Sort#DEFAULT_DIRECTION}
        * @param property must not be {@literal null} or empty.
        */
    public Order(@Nullable Direction direction, String property) {
        this(direction, property, DEFAULT_IGNORE_CASE, DEFAULT_NULL_HANDLING);
    }
    /**
        * Creates a new {@link Order} instance. if order is {@literal null} then order defaults to
        * {@link Sort#DEFAULT_DIRECTION}
        *
        * @param direction can be {@literal null}, will default to {@link Sort#DEFAULT_DIRECTION}
        * @param property must not be {@literal null} or empty.
        * @param nullHandlingHint must not be {@literal null}.
        */
    public Order(@Nullable Direction direction, String property, NullHandling nullHandlingHint) {
        this(direction, property, DEFAULT_IGNORE_CASE, nullHandlingHint);
    }
    /**
        * Creates a new {@link Order} instance. if order is {@literal null} then order defaults to
        * {@link Sort#DEFAULT_DIRECTION}
        *
        * @param direction can be {@literal null}, will default to {@link Sort#DEFAULT_DIRECTION}
        * @param property must not be {@literal null} or empty.
        * @param ignoreCase true if sorting should be case-insensitive. false if sorting should be case-sensitive.
        * @param nullHandling must not be {@literal null}.
        * @since 1.7
        */
    public Order(@Nullable Direction direction, String property, boolean ignoreCase, NullHandling nullHandling) {
        if (!StringUtils.hasText(property)) {
            throw new IllegalArgumentException("Property must not be null or empty");
        }
        this.direction = direction == null ? DEFAULT_DIRECTION : direction;
        this.property = property;
        this.ignoreCase = ignoreCase;
        this.nullHandling = nullHandling;
    }
    /**
        * Creates a new {@link Order} instance. Takes a single property. Direction defaults to
        * {@link Sort#DEFAULT_DIRECTION}.
        *
        * @param property must not be {@literal null} or empty.
        * @since 2.0
        */
    public static Order by(String property) {
        return new Order(DEFAULT_DIRECTION, property);
    }
    /**
        * Creates a new {@link Order} instance. Takes a single property. Direction is {@link Direction#ASC} and
        * NullHandling {@link NullHandling#NATIVE}.
        *
        * @param property must not be {@literal null} or empty.
        * @since 2.0
        */
    public static Order asc(String property) {
        return new Order(Direction.ASC, property, DEFAULT_NULL_HANDLING);
    }
    /**
        * Creates a new {@link Order} instance. Takes a single property. Direction is {@link Direction#DESC} and
        * NullHandling {@link NullHandling#NATIVE}.
        *
        * @param property must not be {@literal null} or empty.
        * @since 2.0
        */
    public static Order desc(String property) {
        return new Order(Direction.DESC, property, DEFAULT_NULL_HANDLING);
    }
    /**
        * Returns the order the property shall be sorted for.
        *
        * @return the order the property shall be sorted for.
        */
    public Direction getDirection() {
        return direction;
    }
    /**
        * Returns the property to order for.
        *
        * @return the property to order for.
        */
    public String getProperty() {
        return property;
    }
    /**
        * Returns whether sorting for this property shall be ascending.
        *
        * @return {@literal true} if ascending, {@literal false} otherwise.
        */
    public boolean isAscending() {
        return this.direction.isAscending();
    }
    /**
        * Returns whether sorting for this property shall be descending.
        *
        * @return {@literal true} if descending, {@literal false} otherwise.
        * @since 1.13
        */
    public boolean isDescending() {
        return this.direction.isDescending();
    }
    /**
        * Returns whether the sort will be case-sensitive or case-insensitive.
        *
        * @return {@literal true} if the sort will be case-sensitive or case-insensitive, {@literal false} otherwise.
        */
    public boolean isIgnoreCase() {
        return ignoreCase;
    }
    /**
        * Returns a new {@link Order} with the given {@link Direction} applied.
        *
        * @param direction the new direction to use.
        * @return a new {@link Order} with the given {@link Direction} applied.
        */
    public Order with(Direction direction) {
        return new Order(direction, this.property, this.ignoreCase, this.nullHandling);
    }
    /**
        * Returns a new {@link Order} with the reversed {@link #getDirection()} applied.
        *
        * @return a reversed {@link Order} with the given {@link Direction} applied.
        * @since 3.1
        */
    public Order reverse() {
        return with(this.direction == Direction.ASC ? Direction.DESC : Direction.ASC);
    }
    /**
        * Returns a new {@link Order} with the {@code property} name applied.
        *
        * @param property must not be {@literal null} or empty.
        * @return a new {@link Order} with the {@code property} name applied.
        * @since 1.13
        */
    public Order withProperty(String property) {
        return new Order(this.direction, property, this.ignoreCase, this.nullHandling);
    }
    /**
        * Returns a new {@link Sort} instance for the given properties using {@link #getDirection()}.
        *
        * @param properties properties to sort by.
        * @return a new {@link Sort} instance for the given properties using {@link #getDirection()}.
        */
    public Sort withProperties(String... properties) {
        return Sort.by(this.direction, properties);
    }
    /**
        * Returns a new {@link Order} with case-insensitive sorting enabled.
        *
        * @return a new {@link Order} with case-insensitive sorting enabled.
        */
    public Order ignoreCase() {
        return new Order(direction, property, true, nullHandling);
    }
    /**
        * Returns a {@link Order} with the given {@link NullHandling} applied.
        *
        * @param nullHandling can be {@literal null}.
        * @return a new {@link Order} with the given {@link NullHandling} applied.
        * @since 1.8
        */
    public Order with(NullHandling nullHandling) {
        return new Order(direction, this.property, ignoreCase, nullHandling);
    }
    /**
        * Returns a new {@link Order} with {@link NullHandling#NULLS_FIRST} as null handling hint applied.
        *
        * @return a new {@link Order} with {@link NullHandling#NULLS_FIRST} as null handling hint applied.
        * @since 1.8
        */
    public Order nullsFirst() {
        return with(NullHandling.NULLS_FIRST);
    }
    /**
        * Returns a new {@link Order} with {@link NullHandling#NULLS_LAST} as null handling hint applied.
        *
        * @return a new {@link Order} with {@link NullHandling#NULLS_LAST} as null handling hint applied.
        * @since 1.7
        */
    public Order nullsLast() {
        return with(NullHandling.NULLS_LAST);
    }
    /**
        * Returns a new {@link Order} with {@link NullHandling#NATIVE} as null handling hint applied.
        *
        * @return a new {@link Order} with {@link NullHandling#NATIVE} as null handling hint applied.
        * @since 1.7
        */
    public Order nullsNative() {
        return with(NullHandling.NATIVE);
    }
    /**
        * Returns the used {@link NullHandling} hint, which can but may not be respected by the used datastore.
        *
        * @return the used {@link NullHandling} hint.
        * @since 1.7
        */
    public NullHandling getNullHandling() {
        return nullHandling;
    }
    @Override
    public int hashCode() {
        int result = 17;
        result = 31 * result + direction.hashCode();
        result = 31 * result + property.hashCode();
        result = 31 * result + (ignoreCase ? 1 : 0);
        result = 31 * result + nullHandling.hashCode();
        return result;
    }
    @Override
    public boolean equals(@Nullable Object obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof Order that)) {
            return false;
        }
        return this.direction.equals(that.direction) && this.property.equals(that.property)
                && this.ignoreCase == that.ignoreCase && this.nullHandling.equals(that.nullHandling);
    }
    @Override
    public String toString() {
        String result = String.format("%s: %s", property, direction);
        if (!NullHandling.NATIVE.equals(nullHandling)) {
            result += ", " + nullHandling;
        }
        if (ignoreCase) {
            result += ", ignoring case";
        }
        return result;
    }
}
```
</div>
</details>

<details>
<summary>public static class TypedSort</summary>
<div markdown="1">        

```java
/**
    * Extension of Sort to use method handles to define properties to sort by.
    *
    * @author Oliver Gierke
    * @since 2.2
    * @soundtrack The Intersphere - Linger (The Grand Delusion)
    */
public static class TypedSort<T> extends Sort {
    private static final @Serial long serialVersionUID = -3550403511206745880L;
    private final Recorded<T> recorded;
    private TypedSort(Class<T> type) {
        this(MethodInvocationRecorder.forProxyOf(type));
    }
    private TypedSort(Recorded<T> recorded) {
        super(Collections.emptyList());
        this.recorded = recorded;
    }
    public <S> TypedSort<S> by(Function<T, S> property) {
        return new TypedSort<>(recorded.record(property));
    }
    public <S> TypedSort<S> by(Recorded.ToCollectionConverter<T, S> collectionProperty) {
        return new TypedSort<>(recorded.record(collectionProperty));
    }
    public <S> TypedSort<S> by(Recorded.ToMapConverter<T, S> mapProperty) {
        return new TypedSort<>(recorded.record(mapProperty));
    }
    @Override
    public Sort ascending() {
        return withDirection(Sort::ascending);
    }
    @Override
    public Sort descending() {
        return withDirection(Sort::descending);
    }
    private Sort withDirection(Function<Sort, Sort> direction) {
        return recorded.getPropertyPath() //
                .map(Sort::by) //
                .map(direction) //
                .orElseGet(Sort::unsorted);
    }
    @Override
    public Iterator<Order> iterator() {
        return recorded.getPropertyPath() //
                .map(Order::by) //
                .map(Collections::singleton) //
                .orElseGet(Collections::emptySet).iterator();
    }
    @Override
    public boolean isEmpty() {
        return recorded.getPropertyPath().isEmpty();
    }
    @Override
    public String toString() {
        return recorded.getPropertyPath() //
                .map(Sort::by) //
                .orElseGet(Sort::unsorted) //
                .toString();
    }
    ...
```
</div>
</details> 
</details>
</details>

<details>
<summary class="summary-title">Order<br>
&emsp;Sort 클래스의 내부 정적 클래스 Order</summary>
<div markdown="1">
- 주요 메서드

```java
desc(): 내림차순으로 정렬
asc(): 오름차순으로 정렬
reverse(): 역순으로 정렬
```
</div>

<details>
<summary>API 내용 확인</summary>
<div markdown="1">    

```java
/**
 * PropertyPath implements the pairing of an {@link Direction} and a property. It is used to provide input for
 * {@link Sort}
 *
 * @author Oliver Gierke
 * @author Kevin Raymond
 * @author Jens Schauder
 */
public static class Order implements Serializable {
    private static final @Serial long serialVersionUID = 1522511010900108987L;
    private static final boolean DEFAULT_IGNORE_CASE = false;
    private static final NullHandling DEFAULT_NULL_HANDLING = NullHandling.NATIVE;
    private final Direction direction;
    private final String property;
    private final boolean ignoreCase;
    private final NullHandling nullHandling;
    /**
     * Creates a new {@link Order} instance. if order is {@literal null} then order defaults to
     * {@link Sort#DEFAULT_DIRECTION}
     *
     * @param direction can be {@literal null}, will default to {@link Sort#DEFAULT_DIRECTION}
     * @param property must not be {@literal null} or empty.
     */
    public Order(@Nullable Direction direction, String property) {
        this(direction, property, DEFAULT_IGNORE_CASE, DEFAULT_NULL_HANDLING);
    }
    /**
     * Creates a new {@link Order} instance. if order is {@literal null} then order defaults to
     * {@link Sort#DEFAULT_DIRECTION}
     *
     * @param direction can be {@literal null}, will default to {@link Sort#DEFAULT_DIRECTION}
     * @param property must not be {@literal null} or empty.
     * @param nullHandlingHint must not be {@literal null}.
     */
    public Order(@Nullable Direction direction, String property, NullHandling nullHandlingHint) {
        this(direction, property, DEFAULT_IGNORE_CASE, nullHandlingHint);
    }
    /**
     * Creates a new {@link Order} instance. if order is {@literal null} then order defaults to
     * {@link Sort#DEFAULT_DIRECTION}
     *
     * @param direction can be {@literal null}, will default to {@link Sort#DEFAULT_DIRECTION}
     * @param property must not be {@literal null} or empty.
     * @param ignoreCase true if sorting should be case-insensitive. false if sorting should be case-sensitive.
     * @param nullHandling must not be {@literal null}.
     * @since 1.7
     */
    public Order(@Nullable Direction direction, String property, boolean ignoreCase, NullHandling nullHandling) {
        if (!StringUtils.hasText(property)) {
            throw new IllegalArgumentException("Property must not be null or empty");
        }
        this.direction = direction == null ? DEFAULT_DIRECTION : direction;
        this.property = property;
        this.ignoreCase = ignoreCase;
        this.nullHandling = nullHandling;
    }
    /**
     * Creates a new {@link Order} instance. Takes a single property. Direction defaults to
     * {@link Sort#DEFAULT_DIRECTION}.
     *
     * @param property must not be {@literal null} or empty.
     * @since 2.0
     */
    public static Order by(String property) {
        return new Order(DEFAULT_DIRECTION, property);
    }
    /**
     * Creates a new {@link Order} instance. Takes a single property. Direction is {@link Direction#ASC} and
     * NullHandling {@link NullHandling#NATIVE}.
     *
     * @param property must not be {@literal null} or empty.
     * @since 2.0
     */
    public static Order asc(String property) {
        return new Order(Direction.ASC, property, DEFAULT_NULL_HANDLING);
    }
    /**
     * Creates a new {@link Order} instance. Takes a single property. Direction is {@link Direction#DESC} and
     * NullHandling {@link NullHandling#NATIVE}.
     *
     * @param property must not be {@literal null} or empty.
     * @since 2.0
     */
    public static Order desc(String property) {
        return new Order(Direction.DESC, property, DEFAULT_NULL_HANDLING);
    }
    /**
     * Returns the order the property shall be sorted for.
     *
     * @return the order the property shall be sorted for.
     */
    public Direction getDirection() {
        return direction;
    }
    /**
     * Returns the property to order for.
     *
     * @return the property to order for.
     */
    public String getProperty() {
        return property;
    }
    /**
     * Returns whether sorting for this property shall be ascending.
     *
     * @return {@literal true} if ascending, {@literal false} otherwise.
     */
    public boolean isAscending() {
        return this.direction.isAscending();
    }
    /**
     * Returns whether sorting for this property shall be descending.
     *
     * @return {@literal true} if descending, {@literal false} otherwise.
     * @since 1.13
     */
    public boolean isDescending() {
        return this.direction.isDescending();
    }
    /**
     * Returns whether the sort will be case-sensitive or case-insensitive.
     *
     * @return {@literal true} if the sort will be case-sensitive or case-insensitive, {@literal false} otherwise.
     */
    public boolean isIgnoreCase() {
        return ignoreCase;
    }
    /**
     * Returns a new {@link Order} with the given {@link Direction} applied.
     *
     * @param direction the new direction to use.
     * @return a new {@link Order} with the given {@link Direction} applied.
     */
    public Order with(Direction direction) {
        return new Order(direction, this.property, this.ignoreCase, this.nullHandling);
    }
    /**
     * Returns a new {@link Order} with the reversed {@link #getDirection()} applied.
     *
     * @return a reversed {@link Order} with the given {@link Direction} applied.
     * @since 3.1
     */
    public Order reverse() {
        return with(this.direction == Direction.ASC ? Direction.DESC : Direction.ASC);
    }
    /**
     * Returns a new {@link Order} with the {@code property} name applied.
     *
     * @param property must not be {@literal null} or empty.
     * @return a new {@link Order} with the {@code property} name applied.
     * @since 1.13
     */
    public Order withProperty(String property) {
        return new Order(this.direction, property, this.ignoreCase, this.nullHandling);
    }
    /**
     * Returns a new {@link Sort} instance for the given properties using {@link #getDirection()}.
     *
     * @param properties properties to sort by.
     * @return a new {@link Sort} instance for the given properties using {@link #getDirection()}.
     */
    public Sort withProperties(String... properties) {
        return Sort.by(this.direction, properties);
    }
    /**
     * Returns a new {@link Order} with case-insensitive sorting enabled.
     *
     * @return a new {@link Order} with case-insensitive sorting enabled.
     */
    public Order ignoreCase() {
        return new Order(direction, property, true, nullHandling);
    }
    /**
     * Returns a {@link Order} with the given {@link NullHandling} applied.
     *
     * @param nullHandling can be {@literal null}.
     * @return a new {@link Order} with the given {@link NullHandling} applied.
     * @since 1.8
     */
    public Order with(NullHandling nullHandling) {
        return new Order(direction, this.property, ignoreCase, nullHandling);
    }
    /**
     * Returns a new {@link Order} with {@link NullHandling#NULLS_FIRST} as null handling hint applied.
     *
     * @return a new {@link Order} with {@link NullHandling#NULLS_FIRST} as null handling hint applied.
     * @since 1.8
     */
    public Order nullsFirst() {
        return with(NullHandling.NULLS_FIRST);
    }
    /**
     * Returns a new {@link Order} with {@link NullHandling#NULLS_LAST} as null handling hint applied.
     *
     * @return a new {@link Order} with {@link NullHandling#NULLS_LAST} as null handling hint applied.
     * @since 1.7
     */
    public Order nullsLast() {
        return with(NullHandling.NULLS_LAST);
    }
    /**
     * Returns a new {@link Order} with {@link NullHandling#NATIVE} as null handling hint applied.
     *
     * @return a new {@link Order} with {@link NullHandling#NATIVE} as null handling hint applied.
     * @since 1.7
     */
    public Order nullsNative() {
        return with(NullHandling.NATIVE);
    }
    /**
     * Returns the used {@link NullHandling} hint, which can but may not be respected by the used datastore.
     *
     * @return the used {@link NullHandling} hint.
     * @since 1.7
     */
    public NullHandling getNullHandling() {
        return nullHandling;
    }
    @Override
    public int hashCode() {
        int result = 17;
        result = 31 * result + direction.hashCode();
        result = 31 * result + property.hashCode();
        result = 31 * result + (ignoreCase ? 1 : 0);
        result = 31 * result + nullHandling.hashCode();
        return result;
    }
    @Override
    public boolean equals(@Nullable Object obj) {
        if (this == obj) {
            return true;
        }
        if (!(obj instanceof Order that)) {
            return false;
        }
        return this.direction.equals(that.direction) && this.property.equals(that.property)
                && this.ignoreCase == that.ignoreCase && this.nullHandling.equals(that.nullHandling);
    }
    @Override
    public String toString() {
        String result = String.format("%s: %s", property, direction);
        if (!NullHandling.NATIVE.equals(nullHandling)) {
            result += ", " + nullHandling;
        }
        if (ignoreCase) {
            result += ", ignoring case";
        }
        return result;
    }
}
```
</div>
</details>
</details>








<br>
<hr>

# 4. 답글 기능

### 답글 알고리즘 (그룹번호, 정렬번호, 들여쓰기)
<br>

<layout style="display: flex; flexflow: nowrap row;">
<div>
<table style="width: 60%; border: solid 0.1px gray;">
    <tr>
        <td colspan="2">&emsp;</td><!-- <td></td> --><td></td><td></td><td></td>
    </tr>
    <tr>
        <th>글번호</th><th>제목</th><th>gnum</th><th>onum</th><th>nested</th>
    </tr>
    <tr>
        <td>1</td><td>A</td><td>1</td><td>0</td><td>0</td>
    </tr>
    <tr>
        <td>2</td><td>B</td><td>2</td><td>0</td><td>0</td>
    </tr>
    <tr>
        <td>3</td><td>&emsp;b1</td><td>2</td><td>3</td><td>0</td>
    </tr>
    <tr>
        <td>4</td><td>&emsp;b2</td><td>2</td><td>1</td><td>0</td>
    </tr>
    <tr>
        <td>5</td><td>&emsp;&emsp;b3</td><td>2</td><td>2</td><td>0</td>
    </tr>
    <tr>
        <td>6</td><td>C</td><td>6</td><td>0</td><td>0</td>
    </tr>
    <tr>
        <td>7</td><td>D</td><td>7</td><td>0</td><td>0</td>
    </tr>
    <tr>
        <td>8</td><td>&emsp;d1</td><td>7</td><td>1</td><td>1</td>
    </tr>
    <tr>
        <td>9</td><td>&emsp;&emsp;d2</td><td>7</td><td>4</td><td>2</td>
    </tr>
    <tr>
        <td>10</td><td>&emsp;&emsp;d3</td><td>7</td><td>2</td><td>2</td>
    </tr>
    <tr>
        <td>11</td><td>&emsp;&emsp;&emsp;d4</td><td>7</td><td>3</td><td>3</td>
    </tr>
</table>
</div>
<div style="width: 10%"></div>
<div>

<table style="width: 30%; border: solid 0.1px gray;">
    <tr>
        <td colspan="2">출력 형태</td><!-- <td></td> --><td>DESC</td><td>ASC</td><td></td>
    </tr>
    <tr>
        <th>글번호</th><th>제목</th><th>gnum</th><th>onum</th><th>nested</th>
    </tr>
    <tr>
        <td>7</td><td>D</td><td>7</td><td>0</td><td>0</td>
    </tr>
    <tr>
        <td>8</td><td>&emsp;d1</td><td>7</td><td>1</td><td>1</td>
    </tr>
    <tr>
        <td>10</td><td>&emsp;&emsp;d3</td><td>7</td><td>2</td><td>2</td>
    </tr>
    <tr>
        <td>11</td><td>&emsp;&emsp;&emsp;d4</td><td>7</td><td>3</td><td>3</td>
    </tr>
    <tr>
        <td>9</td><td>&emsp;&emsp;d2</td><td>7</td><td>4</td><td>2</td>
    </tr>
    <tr>
        <td>6</td><td>C</td><td>6</td><td>0</td><td>0</td>
    </tr>
    <tr>
        <td>2</td><td>B</td><td>2</td><td>0</td><td>0</td>
    </tr>
    <tr>
        <td>4</td><td>&emsp;b2</td><td>2</td><td>1</td><td>0</td>
    </tr>
    <tr>
        <td>5</td><td>&emsp;&emsp;b3</td><td>2</td><td>2</td><td>0</td>
    </tr>
    <tr>
        <td>3</td><td>&emsp;b1</td><td>2</td><td>3</td><td>0</td>
    </tr>
    <tr>
        <td>1</td><td>A</td><td>1</td><td>0</td><td>0</td>
    </tr>
</table>
</div>
</layout>

<br>

