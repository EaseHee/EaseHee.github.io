---
layout: post
title: "Java_01_자바와 객체 지향"
date: 2024-10-04
categories: blog
---

<br>

---

<br>

<dt>절차 지향 vs 객체 지향<dd>
프로그래밍은 과정과 절차, 기능을 중심으로 동작하는 방식과 <br>
기능 수행 단위인 객체를 중심으로 동작하는 방식으로 구분한다고 한다.<br>
대표적으로 C언어는 절차 지향 언어. C++, Python, Java는 객체 지향 언어로 구분한다. <br>
그 차이를 이야기하는 것은 이제 처음 개발이라는 분야에 들어온 사람이 감당하기 어려운 부분이라고 생각하여... <br>
앞으로 다룰 자바의 특징인 객체 지향에 대해서 보고 들은 내용을 돌이켜 보려고 한다.
</dd></dt>

---

<dt>객체 지향 언어<dd>
이름에서도 알 수 있듯이 무언가를 구분하는 단위로써 객체라는 이름을 사용하고 있다. <br>
즉, 객체는 `특정 기능을 수행하는 하나의 단위` 정도로 생각하면 될 것 같다. <br>
객체 지향 프로그램이란 이런 기능 수행 단위로서의 객체를 이용하여 컴퓨터와 소통?하는 것을 의미하는 것이 아닐까 <br>
이런 객체 지향 프로그래밍은 4자기 특징이 있다고 한다.
</dd></dt>

<br><br>

---

<br><br>

객체 지향 프로그래밍의 네 가지 특징
### OOP : Object-Oriented Prodramming 
**1. 추상화**
<br>
객체를 구분하는 과정에서 해당 객체가 가진 여러 특징 중 공통적이고 추상적인 속성, 기능을 추출하는 것.<br>
추상적인 기능을 추출하는 과정에서 특정 객체에서 필요로 하는 단위로 구분하는 것이<br> 
아래에서 다룰 객체 지향 설계를 위한 다섯 가지 원칙의 
네 번째 <strong>인터페이스 분리의 원칙</strong>과도 관련이 있다고 생각한다. <br>
추상화된 객체를 구체화하기 위해서는 상속이라는 개념으로 해결할 수 있다.<br>
<br><br>

**2. 캡슐화**
<br>
캡슐화라는 말은 직역하면 기능과 속성의 단위로서 객체(클래스)를 외부와 구분하는 것으로 볼 수 있다. <br>
객체로 클래스를 구분하고 이 클래스에 접근하기 위해서는 접근할 수 있는 유효 범위를 만족해야 한다.<br>
접근 제한자 혹은 접근 지정자라고 부르는 `public`, `default`, `protected`, `private`가 그 열쇠이다.<br>
속성과 기능으로 객체를 구분했다고 하더라도 유사한 속성, 기능의 경우 따로 구분하거나 묶어줄 필요가 있는데 <br>
이 때, 패키지라는 개념으로 객체를 묶어줄 수 있다. <br>
이렇게 패키지로 객체를 구분한 경우 접근의 제한에서 비교적 자유로워질 수 있는데 이는 `default`와 관련이 있다. <br>
접근을 제한하는 범위가 가장 좁은 건 `private`으로 의미 그대로 사적인, 보호되는 뜻이다. <br>
캡슐화된 객체는 외부로부터의 접근을 제한하며 객체의 속성, 기능의 노출을 막을 수 있다. <br>
이렇게 <strong>객체의 정보를 보호하고 숨기는 것</strong>이 캡슐화의 핵심이라고 한다.
<br><br>

**3. 상속성**
<br>
객체를 추상화하여 특정 기능으로 구분하고 분리했다면 <strong>해당 기능을 구체화할 수 있도록</strong> 길을 열어두어야 한다. <br>
그 길이 바로 상속과 구현이다. <br>
추상화된 객체를 구체화하기 위해서 상속하며 자식은 해당 기능의 기본 뼈대를 상속받게 된다. <br>
뼈대에 살을 붙이는 과정이 오버라이딩이다. <br> 
익숙하지 않은 용어에 오버로딩과 헷갈리는 경우가 있는데 이는 다형성에서 다루려고 한다.<br>
상속 관계에서는 참조 여부가 중요한 개념이 되는데 부모는 자식을 참조(참조 주소값을 저장)할 수 있지만 자식은 부모를 참조할 수 없다.<br> 
부모는 자식의 참조값을 저장할 수 있다는 것 때문에 매개변수의 타입을 정하는 시점에서 <br>
여러 자식의 타입이 서로 다른 경우 구체적인 하나의 자식 타입이 아닌 부모의 타입으로 설정할 수 있다.<br>
이로써 인자로 모든 자식을 전달받더라도 정상적으로 작동할 수 있다.
<br><br>

**4. 다형성**
<br>
하나의 객체가 다양한 기능을 수행할 수 있도록 하는 개념으로 상속과 유사하지만.<br>
상속은 객체의 데이터 타입이 결정되는 수직적인 방향의 기능 확장이라면<br>
다형성은 객체가 수행할 수 있는 기능(역할)이 넓어지는 수평적인 방향의 기능 확장처럼 보인다.<br>
위의 상속성에서 언급한 `메서드 오버로딩`이 다형성의 대표적인 예이다.<br>
오버로딩은 과적(많이 쌓았다는 뜻)으로 같은 메서드를 매개 변수의 타입과 개수를 다르게 설정하여 <br>
동일한 기능을 수행하는 메서드를 하나의 이름으로 여러 상황에 맞게 사용할 수 있도록 길을 열어둔 것이다. <br>
이는 바로 다음에 다룰 네 번째 특징인 다형성과 그 다음에 다룰 객체 지향 설계를 위한 다섯 가지 원칙의 
두 번째 <strong>개방 폐쇄의 원칙</strong>과도 관련이 있다고 생각한다. <br>
<br><br>

이미 언급했듯 이런 객체 지향 프로그램을 설계하기 위한 중요한 다섯 가지 원칙이 있다고 한다. 

<br><br>

---

<br><br>

### 객체 지향 설계의 다섯 가지 원칙 (SOLID)

**1. 단일 책임 원칙**<br>
- **SRP : Single Responsibility Principle**
 
하나의 클래스나 메서드는 `하나의 기능만을 수행`해야 한다는 것이다. <br>
즉, 다른 기능을 수행해야 하는 경우, 별도의 클래스나 메서드로 분리해야 한다는 것이 첫 번째 원칙이다. <br>
기능에 맞는 단위로서의 캡슐화가 그 핵심이 아닐까 생각해본다.


<br>

**2. 개방 폐쇄 원칙**
- **OCP : Open-Closed Principle**
 
자바에서는 특정 클래스나 인터페이스를 상속하거나 구현할 수 있다. <br>
이처럼 부모의 기능을 확장하는 데에는 열려 있고, <br>
기능을 수정하거나 추가할 때에는 자식의 로직 전부를 수정하지 않고 <br>
부모(클래스 혹은 인터페이스)의 로직만을 수정하도록 <br>
기능 수정, 추가에는 닫혀있는 설계를 지향하는 것이 두 번째 원칙이다.


<br>

**3. 리스코프 치환 원칙**
- **LSP : Liskov Subtituition Principle**

(Subtitution) 치환 혹은 대체라는 건 바꾼다는 의미인데 <br>
상속 관계에서 `자식은 부모의 기능을 모두 수행할 수 있어야 한다`는 뜻이다. <br>
이 원칙은 다형성과도 연관이 있는 것 같다. <br>
이렇게 자식을 부모로 대체하는 경우에도 기능에서 문제가 없도록 하는 것이 세 번째 원칙이다.


<br>

**4. 인터페이스 분리 원칙**
- **ISP : Interface Segregation Principle**

인터페이스란 실체를 가질 수 없는 클래스로 구현을 목적으로 존재한다. <br>
자바에서는 클래스의 다중 상속을 지원하지 않기 때문에 여러 기능을 동시에 수행하기 위해서는 인터페이스를 구현하는 방식으로 해결해야 한다. <br>
즉, 인터페이스는 다중 구현이 가능하다는 의미로 추상 클래스와의 가장 큰 차이라고 할 수 있다. <br>
<strong>추상클래스는 추상메서드를 하나 이상 가지고 있는 클래스</strong>로 추상메서드는 자식이 반드시 구현해야 하는 메서드가 된다. <br>
> cf. final 메서드는 자식이 오버라이딩할 수 없다. final 클래스는 상속할 수 없다.<br> 
반드시 구현해야 하는 기능이 있는 경우 인터페이스가 아닌 추상클래스로 생성한다.  <br>
`ex. InputStream : read()와 같은 구체적인 기능을 정의`

다중 상속을 위해 인터페이스는 기능으로 구분되고, 기능에 특화되다보니 `-able` 이라는 접미사를 이름에 붙이는 경우가 많다. 
> `ex. Iterable, Comparable, ...`

하지만 인터페이스는 구현하게 되면 해당 인터페이스가 가지고 있는 모든 메서드를 재정의해야 한다. <br> 
필요 없는 기능의 메서드까지 재정의해야 하는 문제를 막기 위해 <br>
인터페이스를 해당 기능을 기준으로 분리한 후 필요한 기능의 인터페이스만을 구현하도록 하는 것이 네 번째 원칙이다. <br>
이건 첫 번째 원칙인 단일 책임 원칙과도 관련이 있는 것 같다.


<br>

**5. 의존성 역전 원칙**
- **DIP : Dependency Inversion PrinCiple**

객체는 기능에 따라 분리되어 있으며, 필요 시 해당 객체의 인스턴스를 생성한 후 기능을 수행할 수 있다.<br>
이렇게 다른 객체를 상속하거나 구현하는 경우 의존관계가 생기게 된다. <br>
이 경우 부모가 구체적인 기능을 수행하고 있고 자식이 이를 상속하게 된다면 <br>
자식은 해당 기능을 오버라이딩하지 않고 상속받아 사용할 수 있다.<br>
하지만 자식이 다른 기능으로 변경하기 위해서는 다른 부모를 상속해야 하고<br>
현재 부모를 상속함으로 수행할 수 있던 구체적인 기능이 의존 관계에 의해 문제가 생기게 된다.<br>
만약 여러 객체에서 필요로 하는 기능이 있다면 해당 기능의 공통점을 추상화하여 인터페이스로 분리하는 것이  <br>
해당 인터페이스만 구현하는 것으로 동일한 기능을 구현하면서도 다른 부모를 상속하더라도 기능을 정상적으로 수행할 수 있게 된다.
